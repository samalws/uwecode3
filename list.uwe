{basics}
{tup}
{bool}
{either}
{nat}
{nFuncs}
[List t: (t -> a -> a) -> a -> a]
emptyList = ignore
consList = h -> r -> f -> g -> f h `id f r g
List->ScottList = nRev 2 (h -> r -> f -> const `id f h r) emptyList
ScottList->List = fix self -> nRev 2 (h -> r -> h `consList self r) emptyList
singleList = rev emptyList `comp consList
mapList = f -> nRev 2 (consList `comp f) emptyList
replaceList = f -> x -> mapList y -> f y x y
filterList = f -> nRev 2 (h -> r -> f h (h `consList r) r) emptyList
lenList = nRev 2 succNat 0
isEmptyList = nRev 2 (const true) false
headList = nRev 2 (const `comp just) none
tailList = ScottList->List `comp nRev 2 (nComp 2 just ignore) none `comp List->ScottList
getList = fix self -> n -> l -> isZeroNat n (headList l) `id self (decNat n) (tailList l)
concatList = rev consList
mergeList = f -> a -> b -> (fix self -> a -> b -> a (ha -> ra -> b (hb -> rb -> f ha hb `consList self ra rb) emptyList) emptyList) (List->ScottList a) (List->ScottList b)
eqList = f -> nRev 2 andBool true `(nComp 2) mergeFolded f
[TODO reverse, sort]
